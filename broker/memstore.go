package broker

import (
	"encoding/json"
	"fmt"
	"sync"
)

// MemStoreDriver is a struct that represents a memory store driver.
type MemStoreDriver struct {
}

func (d MemStoreDriver) Open(jsonConfig json.RawMessage) (Store, error) {
	return newMemStore()
}

// MemStore represents an in-memory message store used by the broker.
type MemStore struct {
	sync.Mutex

	msgID int64

	msgs map[string][]*msg
}

// newMemStore creates a new instance of MemStore.
// It initializes the message ID to 0 and creates an empty map for storing messages.
func newMemStore() (*MemStore, error) {
	s := new(MemStore)

	s.msgID = 0
	s.msgs = make(map[string][]*msg)

	return s, nil
}

// GenerateID generates a unique ID for messages in the MemStore.
// It increments the message ID and returns the new ID.
// The function is thread-safe.
func (s *MemStore) GenerateID() (int64, error) {
	s.Lock()
	defer s.Unlock()

	s.msgID++
	return s.msgID, nil
}

// key returns the key for the given queue.
// The key is generated by formatting the queue string.
func (s *MemStore) key(queue string) string {
	return fmt.Sprintf("%s", queue)
}

// Close closes the MemStore and releases any resources associated with it.
// It returns an error if there was a problem closing the MemStore.
func (s *MemStore) Close() error {
	return nil
}

// Save saves a message to the specified queue in the memory store.
// It appends the message to the existing messages in the queue.
// If the queue does not exist, a new queue is created.
// The function is thread-safe and uses a lock to ensure concurrent access safety.
// Parameters:
//   - queue: The name of the queue to save the message to.
//   - m: The message to be saved.
//
// Returns:
//   - error: An error if the operation fails, nil otherwise.
func (s *MemStore) Save(queue string, m *msg) error {
	key := s.key(queue)

	s.Lock()
	defer s.Unlock()

	q, ok := s.msgs[key]
	if !ok {
		q = make([]*msg, 0, 1)
	}

	s.msgs[key] = append(q, m)

	return nil
}

// Delete removes a message with the specified msgId from the queue identified by the given queue name.
// If the queue does not exist or the message with the specified msgId is not found, it returns nil.
// Otherwise, it removes the message from the queue and updates the internal state of the MemStore.
func (s *MemStore) Delete(queue string, msgId int64) error {
	key := s.key(queue)

	s.Lock()
	defer s.Unlock()

	q, ok := s.msgs[key]
	if !ok {
		return nil
	}

	for i, m := range q {
		if m.id == msgId {
			copy(q[i:], q[i+1:])
			q[len(q)-1] = nil

			q = q[:len(q)-1]
			if len(q) == 0 {
				delete(s.msgs, key)
			} else {
				s.msgs[key] = q
			}

			return nil
		}
	}

	return nil
}

// Pop removes and returns the first message from the specified queue in the memory store.
// If the queue is empty or does not exist, it returns nil.
func (s *MemStore) Pop(queue string) error {
	key := s.key(queue)

	s.Lock()
	defer s.Unlock()

	q, ok := s.msgs[key]
	if !ok {
		return nil
	}

	if len(q) == 0 {
		return nil
	}

	copy(q[0:], q[1:])
	q[len(q)-1] = nil
	s.msgs[key] = q[:len(q)-1]

	return nil
}

// Len returns the length of the message queue for the specified queue.
// If the queue does not exist, it returns 0.
func (s *MemStore) Len(queue string) (int, error) {
	key := s.key(queue)

	s.Lock()
	defer s.Unlock()

	q, ok := s.msgs[key]
	if !ok {
		return 0, nil
	}

	return len(q), nil
}

// Front returns the front message in the specified queue.
// If the queue is empty or does not exist, it returns nil.
func (s *MemStore) Front(queue string) (*msg, error) {
	key := s.key(queue)

	s.Lock()
	defer s.Unlock()

	q, ok := s.msgs[key]
	if !ok {
		return nil, nil
	}

	if len(q) == 0 {
		return nil, nil
	} else {
		return q[0], nil
	}
}

// init is a special function in Go that is automatically called when the package is initialized.
// It registers the "mem" store driver with the MemStoreDriver implementation.
func init() {
	RegisterStore("mem", MemStoreDriver{})
}
